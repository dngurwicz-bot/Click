import { createClient } from '@/lib/supabase/client'
import { Employee } from '@/types/employee'

// Interfaces
export interface Organization {
  id: string
  internal_id?: string
  name: string
  hp?: string
  contact_name?: string
  contact_email?: string
  is_active: boolean
  modules?: string[]
  is_master?: boolean
  sync_with_master?: boolean
  created_at: string
  updated_at: string
}

export interface OrgUser {
  id: string
  email: string
  name: string
  role: 'admin' | 'manager' | 'employee'
  org_id: string
}

class ApiClient {
  private supabase = createClient()

  // Organizations
  async getOrganizations() {
    const { data, error } = await this.supabase
      .from('organizations')
      .select('*')
      .order('created_at', { ascending: false })

    if (error) throw error
    return data as Organization[]
  }

  async getCurrentEmployee() {
    const { data: { user } } = await this.supabase.auth.getUser()
    if (!user) return null

    const { data, error } = await this.supabase
      .from('employees')
      .select('*')
      .eq('id', user.id)
      .single()

    if (error) {
      console.error('Error fetching employee profile:', error)
      return null
    }
    return data as Employee
  }


  async createOrganization(org: { name: string; hp?: string; contact_name?: string; contact_email?: string; is_active: boolean; modules?: string[] }) {
    // Note: internal_id is generated by the database if the column exists and has a default/sequence
    const { data, error } = await this.supabase
      .from('organizations')
      .insert([org])
      .select()
      .single()

    if (error) throw error
    return data as Organization
  }

  async updateOrganization(id: string, updates: Partial<Organization>) {
    const { data, error } = await this.supabase
      .from('organizations')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return data as Organization
  }

  async deleteOrganization(id: string) {
    const { error } = await this.supabase
      .from('organizations')
      .delete()
      .eq('id', id)

    if (error) throw error
    return true
  }

  // Organization Users
  async getOrgUsers(orgId: string) {
    // Note: This requires a 'users' or 'organization_users' table which might not exist yet in the real DB.
    // For this simple implementation, we'll try to insert into a 'users' table or return empty if not found.
    // Typically users are handled via Supabase Auth and a public profiles table.

    const { data, error } = await this.supabase
      .from('users') // Assuming a users table in public schema
      .select('*')
      .eq('org_id', orgId)

    if (error) {
      console.warn('Error fetching users (table might not exist):', error)
      return []
    }
    return data as OrgUser[]
  }

  async createOrgUser(orgId: string, userData: { name: string; email: string; role: string }) {
    // In a real app this should create a Supabase Auth user + public profile
    // Here we just insert into 'users' table for simplicity as per requirement
    const { data, error } = await this.supabase
      .from('users')
      .insert([{ ...userData, org_id: orgId }])
      .select()
      .single()

    if (error) throw error
    return data as OrgUser
  }

  // Updates
  async getUpdates(orgId?: string) {
    let query = this.supabase
      .from('updates')
      .select('*')
      .order('created_at', { ascending: false })

    // Fetch updates that are either for this org OR are global
    if (orgId) {
      query = query.or(`org_id.eq.${orgId},is_global.eq.true`)
    }

    const { data, error } = await query

    if (error) {
      // If table doesn't exist yet, return empty to avoid crash during dev
      console.warn('Error fetching updates:', error)
      return []
    }
    return data
  }

  async createUpdate(update: { org_id?: string; title: string; content: string; link?: string; link_text?: string; is_global?: boolean }) {
    const { data, error } = await this.supabase
      .from('updates')
      .insert([update])
      .select()
      .single()

    if (error) throw error
    return data
  }

  async deleteUpdate(id: string) {
    const { error } = await this.supabase
      .from('updates')
      .delete()
      .eq('id', id)

    if (error) throw error
    return true
  }

  async updateUpdate(id: string, update: { title?: string; content?: string; link?: string; link_text?: string }) {
    const { data, error } = await this.supabase
      .from('updates')
      .update(update)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  // Employee Events
  async getEventData(employeeId: string, eventTypeId: number) {
    // This assumes a table 'employee_events' exists. If not, it will return empty/error at runtime but fix build.
    const { data, error } = await this.supabase
      .from('employee_events')
      .select('*')
      .eq('employee_id', employeeId)
      .eq('event_type_id', eventTypeId)

    if (error) {
      console.warn('Error fetching event data (table might not exist):', error)
      return []
    }
    return data
  }

  async updateEventData(employeeId: string, eventTypeId: number, eventData: any) {
    // This is a simplified upsert/insert implementation
    // In a real scenario, you might want to replace all data for this event type or merge

    // For now, let's assume we are inserting/upserting rows
    const payload = Array.isArray(eventData) ? eventData : [eventData]

    // Add IDs
    const records = payload.map((p: any) => ({
      ...p,
      employee_id: employeeId,
      event_type_id: eventTypeId
    }))

    const { data, error } = await this.supabase
      .from('employee_events')
      .upsert(records)
      .select()

    if (error) throw error
    return data
  }


  // Read Updates Tracking
  async markUpdateAsRead(updateId: string) {
    const { data: { user } } = await this.supabase.auth.getUser()
    if (!user) return

    const { error } = await this.supabase
      .from('read_updates')
      .insert({
        user_id: user.id,
        update_id: updateId
      })

    if (error) {
      // Ignore unique violation (already read)
      if (error.code !== '23505') {
        console.error('Error marking update as read:', error)
        throw error
      }
    }
  }

  async getUnreadGlobalUpdates() {
    // 1. Get all global updates
    const { data: globalUpdates, error: updatesError } = await this.supabase
      .from('updates')
      .select('*')
      .eq('is_global', true)
      .order('created_at', { ascending: false })

    if (updatesError || !globalUpdates || globalUpdates.length === 0) return []

    // 2. Get user's read updates
    const { data: { user } } = await this.supabase.auth.getUser()
    if (!user) return []

    const { data: readUpdates, error: readError } = await this.supabase
      .from('read_updates')
      .select('update_id')
      .eq('user_id', user.id)

    if (readError) {
      console.warn('Error fetching read updates:', readError)
      return [] // Fail safe
    }

    const readUpdateIds = new Set(readUpdates?.map(r => r.update_id) || [])

    // 3. Filter
    return globalUpdates.filter(u => !readUpdateIds.has(u.id))
  }
}

export const api = new ApiClient()
